
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>FLAPPY TURD</title>
  <style>
    body { margin: 0; background: #000; overflow: hidden; }
    canvas { display: block; margin: 0 auto; background: #000; }
    #loading { position: absolute; width: 100%; text-align: center; top: 40%; font-size: 1.5em; color: #fff; }
  </style>
</head>
<body>
  <div id="loading">Loading Flappy Turd...</div>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const poopImg = new Image(); poopImg.src = 'assets/poop.png';
    const splatImg = new Image(); splatImg.src = 'assets/splat.png';
    const splatSound = new Audio('assets/splat.mp3');

    const bgImg = new Image();
    bgImg.src = 'assets/sewer1_scrollable.png';
    let bgX = 0;

    const pipeImgs = ['Pipe1.png','Pipe2.png','Pipe3.png','Pipe4.png','Pipe5.png','Pipe6.png'].map(src => {
      const img = new Image(); img.src = 'assets/' + src; return img;
    });

    let turdY = 300, velocity = 0, gravity = 0.4, lift = -7;
    let score = 0, longestStreak = localStorage.getItem('longestStreak') || 0;
    let obstacles = [], frame = 0, gameOver = false;

    function preloadAssets(callback) {
      let assets = [poopImg, splatImg, bgImg, ...pipeImgs];
      let loaded = 0;
      assets.forEach(img => {
        img.onload = () => {
          loaded++;
          if (loaded === assets.length) callback();
        };
        img.onerror = () => {
          console.error('Failed to load:', img.src);
        };
      });
    }

    document.addEventListener('keydown', flap);
    document.addEventListener('touchstart', flap);

    function flap() {
      if (gameOver) location.reload();
      velocity = lift;
    }

    function addObstacle() {
      const gap = 100;
      const top = Math.random() * 200 + 50;
      const pipeIndex = Math.floor(Math.random() * pipeImgs.length);
      obstacles.push({
      x: canvas.width,
      top: top,
      bottom: top + gap,
      img: pipeImgs[pipeIndex],
      visualTop: top - 300 + 20,
      visualBottom: top + gap
    });
    }

    function update() {
      if (gameOver) return;
      velocity += gravity;
      turdY += velocity;
      frame++;

      if (frame % 100 === 0) addObstacle();
      obstacles.forEach(o => o.x -= 2);

      for (let obs of obstacles) {
        let pipeX = obs.x;
let pipeWidth = 80;
let pipeTopY = obs.top - 300 + 20;
let pipeBottomY = obs.bottom;

if (
  65 + 30 > pipeX &&
  65 < pipeX + pipeWidth &&
  (turdY - 15 < pipeTopY + 300 || turdY + 15 > pipeBottomY)
) {
          gameOver = true;
          splatSound.play();
        }
      }

      if (turdY < 0 || turdY > canvas.height) gameOver = true;
      if (!gameOver) score++;

      // scroll background
      bgX -= 1;
      if (bgX <= -canvas.width) {
        bgX = 0;
      }
    }

    function draw() {
  // DEBUG: draw collision zones
  for (let obs of obstacles) {
    let visualTop = obs.top - 300 + 20;
    let visualBottom = obs.bottom;

    // Top pipe collision area (bottom edge of top pipe)
    ctx.fillStyle = "rgba(255,0,0,0.2)";
    ctx.fillRect(obs.x, 0, 80, visualTop + 40);

    // Bottom pipe collision area (top edge of bottom pipe)
    ctx.fillRect(obs.x, visualBottom - 40, 80, canvas.height - (visualBottom - 40));
  }

  // DEBUG: draw poop hitbox
  ctx.fillStyle = "rgba(0,0,255,0.3)";
  ctx.fillRect(65, turdY - 15, 30, 30);

      ctx.drawImage(bgImg, bgX, 0, canvas.width, canvas.height);
      ctx.drawImage(bgImg, bgX + canvas.width, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#fff';
      ctx.font = '20px sans-serif';
      ctx.fillText("Streak: " + score, 10, 30);
      ctx.fillText("Longest: " + longestStreak, 10, 60);

      ctx.drawImage(poopImg, 65, turdY - 15, 30, 30);

      for (let obs of obstacles) {
        ctx.drawImage(obs.img, obs.x, obs.top - 300 + 20, 80, 300);
        ctx.save();
        ctx.translate(obs.x + 125, obs.bottom + 200);
        ctx.scale(1, -1);
        ctx.drawImage(obs.img, -40, -150 - 20, 80, 300);
        ctx.restore();
      }
  // DEBUG: draw collision zones
  for (let obs of obstacles) {
    let visualTop = obs.top - 300 + 20;
    let visualBottom = obs.bottom;

    // Top pipe collision area (bottom edge of top pipe)
    ctx.fillStyle = "rgba(255,0,0,0.2)";
    ctx.fillRect(obs.x, 0, 80, visualTop + 40);

    // Bottom pipe collision area (top edge of bottom pipe)
    ctx.fillRect(obs.x, visualBottom - 40, 80, canvas.height - (visualBottom - 40));
  }

  // DEBUG: draw poop hitbox
  ctx.fillStyle = "rgba(0,0,255,0.3)";
  ctx.fillRect(65, turdY - 15, 30, 30);


  if (gameOver) {
        if (score > longestStreak) {
          longestStreak = score;
          localStorage.setItem('longestStreak', longestStreak);
        }

  // DEBUG: draw collision zones even after game over
  for (let obs of obstacles) {
    ctx.fillStyle = "rgba(255,0,0,0.2)";
    ctx.fillRect(obs.x, obs.top - 300 + 20, 80, 300); // top pipe box
    ctx.save();
    ctx.translate(obs.x + 40, obs.bottom);
    ctx.scale(1, -1);
    ctx.fillStyle = "rgba(255,0,0,0.2)";
    ctx.fillRect(-40, -150 - 20, 80, 300);
    ctx.restore(); // bottom pipe box
  }

  // DEBUG: draw poop hitbox
  ctx.fillStyle = "rgba(0,0,255,0.3)";
  ctx.fillRect(65, turdY - 15, 30, 30);

        ctx.drawImage(splatImg, 60, turdY - 15, 50, 50);
        ctx.fillStyle = 'red';
        ctx.font = '30px sans-serif';
        ctx.fillText('ðŸ’¥ SPLAT!', canvas.width / 2 - 60, canvas.height / 2);
        ctx.font = '20px sans-serif';
        ctx.fillText('Tap or Press to Restart', canvas.width / 2 - 100, canvas.height / 2 + 40);
      }
    }

    function loop() {
      update();
      draw();
      if (!gameOver) requestAnimationFrame(loop);
    }

    preloadAssets(() => {
      document.getElementById('loading').style.display = 'none';
      loop();
    });
  </script>
</body>
</html>
